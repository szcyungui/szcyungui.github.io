---
layout:     post
title:    2020-06-28-JS_闭包
date:       2020-06-28
author:     Yungui
header-img: img/post-bg-ios9-web.jpg
catalog: true
tags: 
    - 函数式编程
    - ES6
---
JavaScript 变量可以是局部变量或全局变量，私有变量可以用到闭包。 

## 全局变量和局部变量 

函数可以访问由函数内部定义的变量，如： 

```javascript
function myFunction() { 
var a = 4; 
    return a * a; 
} 
```
函数也可以访问函数外部定义的变量，如： 
```plain
var a = 4; 
function myFunction() { 
    return a * a; 
} 
```
后面一个实例中， a 是一个 全局 变量，在web页面中全局变量属于 window 对象，全局变量可应用于页面上的所有脚本。 
在第一个实例中， a 是一个 局部 变量，局部变量只能用于定义它函数内部。对于其他的函数或脚本代码是不可用的。 

全局和局部变量即便名称相同，它们也是两个不同的变量。修改其中一个，不会影响另一个的值。 

**变量声明时如果不使用 var 关键字，那么它就是一个全局变量，即便它在函数内定义** 。 

## 计数器困境 

--  不详细说明了。总之就是，如果定义全局变量count 那么页面上的任何操作都有可能导致count的数值发生变化，影响计数器，但是如果把count定义在add函数内部，那么在外部无法访问，且每次都会重复刷新。 

```plain
// 之前一直没注意到，这里的add是首先被后面的自我调用函数进行了其中子 
// 函数的赋值，这也是很重要的灵魂之举！ 
var add = (function () { 
    var counter = 0; 
    return function () {return counter += 1;} 
})(); 
add(); 
add(); 
add(); 
// 计数器为 3 
```
变量 add 指定了函数自我调用的返回字值。 
自我调用函数只执行一次。设置计数器为 0。并返回函数表达式。 

add变量可以作为一个函数使用。非常棒的部分是它可以访问函数上一层作用域的计数器。 

这个叫作 **JavaScript 
闭包。** 它使得 **函数拥有私有变量变成可能** 。 

计数器受匿名函数的作用域保护，只能通过 add 方法修改。 

```plain
闭包是一种保护私有变量的机制，在函数执行时形成私有的作用域，保护里面的私有变量不受外界干扰。 
直观的说就是形成一个不销毁的栈环境。 
```
